---
description: Core AI behavior optimization rules for prompt analysis, user approval requirements, and task management with clear separation of terminal vs editor usage
globs: ['**/*']
alwaysApply: true
---

# Core AI Behavior and User Approval Rules

## Core Principle
- **NEVER execute any action without explicit user approval**
- **ALWAYS ask before making changes, additions, or implementations**
- **Wait for user confirmation before proceeding with any task**
- **Follow strict user approval protocols for all operations**

## 1. User Approval Requirement (CRITICAL - 100% Compliance)

### MANDATORY User Approval Actions
- **File modifications** - Ask before editing any existing files
- **New file creation** - Ask before creating new files or directories
- **Code deletions** - Ask before removing any code or files
- **Refactoring** - Ask before restructuring existing code
- **New functionality** - Ask before implementing new features
- **API integrations** - Ask before adding external services
- **Database changes** - Ask before modifying data structures
- **Configuration updates** - Ask before changing settings
- **Directory creation** - Ask before creating new folders
- **File organization** - Ask before moving or reorganizing files
- **Dependency management** - Ask before adding/removing packages
- **Build configuration** - Ask before modifying build processes

### Approval Process (MANDATORY)
1. **Describe what you want to do** in detail
2. **Explain why it's needed** or beneficial
3. **Ask specific permission** - "Should I proceed with X?"
4. **Wait for user response** before continuing
5. **Confirm the approved actions** before proceeding
6. **Execute only what was approved**
7. **Report back on completion**

### Approval Questions Format (REQUIRED)
```
I need to [action] because [reason]. 

Should I proceed with:
- [specific action 1]
- [specific action 2]
- [specific action 3]

Please confirm if you want me to proceed with these changes.
```

### When User Approval is NOT Required
- **Information only** - Explaining concepts or providing information
- **Suggesting approaches** without implementation
- **Analyzing code** or identifying issues
- **Providing examples** in chat (not in files)
- **Direct user commands** like "create this file"
- **Explicit user instructions** like "add this function"
- **User-initiated changes** that are clearly requested

## 2. Prompt Analysis (CRITICAL - 100% Compliance)

### Complete Prompt Reading Requirements
- **Always read user chat prompts completely** before responding
- **Analyze full context, requirements, and constraints**
- **Identify key objectives and specific requests**
- **Ask clarifying questions if anything is unclear**
- **Never skip any part of user instructions**

## 3. Documentation-First Approach (IMPORTANT - 95% Compliance)

### Official Documentation Priority
- **Always search and reference official documentation**
- **Prioritize official sources over unofficial information**
- **Use latest API versions and features**
- **Cite specific documentation sections**
- **Follow official documentation policies strictly**

## 4. Latest Coding Standards (IMPORTANT - 95% Compliance)

### Modern Development Practices
- **Use current, optimized approaches and methods**
- **Follow modern best practices and design patterns**
- **Implement latest language features**
- **Avoid deprecated patterns**
- **Stay updated with latest standards**

## 5. Policy Compliance (CRITICAL - 100% Compliance)

### Chrome Web Store Compliance
- **Chrome Web Store compliance** - ensure all code follows latest August 2025 policies
- **Manifest V3 requirements** - use only approved Chrome extension patterns
- **Code readability standards** - maintain clear, non-obfuscated code
- **Adhere to security best practices**
- **Respect licensing requirements**
- **Follow platform-specific guidelines**

## 6. Terminal-First Scanning Requirement (CRITICAL - 100% Compliance)

### MANDATORY Terminal Usage for Scanning and Understanding
- **ALWAYS use terminal commands FIRST** for scanning and understanding codebase
- **Terminal commands are for finding what to edit** - NOT for editing code
- **Use terminal to identify exact locations** for changes before using Cursor AI editor
- **Never assume anything** - always scan through terminal first
- **Follow terminal-first scanning approach** for all operations

### Terminal Commands for File Operations (SCANNING ONLY)
```bash
# ALWAYS use these commands FIRST for scanning and understanding:

# Get file size and line count
wc -l filename.mjs
ls -lh filename.mjs

# Read entire file (use for smaller files)
cat filename.mjs
cat -n filename.mjs

# Read large files in segments
sed -n '1,200p' filename.mjs
sed -n '201,400p' filename.mjs

# Find specific content
grep -n "pattern" filename.mjs
grep -n -A 5 -B 5 "pattern" filename.mjs

# Find all function definitions
grep -n "function\|class\|export" filename.mjs

# Find all import statements
grep -n "import" filename.mjs
```

### Why Terminal First for Scanning
- **Faster execution** - Terminal commands execute instantly
- **More reliable** - No AI generation errors or hallucinations
- **Precise location finding** - Exact line numbers and content
- **Better performance** - No token usage or network delays
- **Immediate results** - See file structure instantly
- **Version control friendly** - Easy to track what was scanned

## 7. Cursor AI Editor Usage (CRITICAL - 100% Compliance)

### MANDATORY Cursor AI Editor Usage for Code Changes
- **ALWAYS use Cursor AI editor** for ALL actual code changes
- **Terminal scanning is ONLY for understanding** - never for editing
- **Use Cursor AI editor for** adding, editing, deleting, or modifying code
- **Cursor AI editor is the ONLY way** to make code changes
- **Terminal commands are FORBIDDEN** for code modifications

### Cursor AI Editor Actions (MANDATORY)
- **✅ File creation** - Use Cursor AI editor for new files
- **✅ Code writing** - Use Cursor AI editor for code changes
- **✅ File modification** - Use Cursor AI editor for edits
- **✅ Content generation** - Use Cursor AI editor for new content
- **✅ Code refactoring** - Use Cursor AI editor for restructuring

### Terminal Commands Actions (FORBIDDEN for Code Changes)
- **❌ File creation** - Never use terminal for creating files with content
- **❌ Code writing** - Never use terminal for writing code
- **❌ File modification** - Never use terminal for editing code
- **❌ Content generation** - Never use terminal for generating content
- **❌ Code refactoring** - Never use terminal for restructuring code

## 8. Workflow: Terminal First, Then Cursor AI Editor

### Step 1: Terminal Scanning (MANDATORY)
```bash
# Use terminal to understand the codebase
wc -l filename.mjs                    # Get line count
ls -lh filename.mjs                   # Get file size
head -50 filename.mjs                 # Read beginning
tail -50 filename.mjs                 # Read end
grep -n "pattern" filename.mjs        # Find specific content
```

### Step 2: Cursor AI Editor Changes (MANDATORY)
- **After terminal scanning**, use Cursor AI editor for all code changes
- **Terminal scanning provides context** for what needs to be changed
- **Cursor AI editor implements the changes** based on terminal understanding
- **No code changes through terminal** - only through Cursor AI editor

### Step 3: Verification (MANDATORY)
- **Use terminal commands** to verify changes were applied correctly
- **Check file content** using terminal commands
- **Verify no errors** in the modified files
- **Confirm changes match** what was intended

## 9. Task Management (IMPORTANT - 95% Compliance)

### Task Division Strategy
- **Divide complex tasks** into manageable parts
- **Focus on specific changes** rather than complete rewrites
- **Use professional TODOs** for progress tracking
- **Prevent token overflow** and network errors
- **Break large projects** into logical segments

### Token Efficiency
- **Prevent token overflow** by dividing complex tasks
- **Use incremental approaches** for large modifications
- **Focus on specific functionality** rather than complete rewrites
- **Maintain context** across task segments

## 11. 🚨 **NEW CRITICAL RULE: FILE REWRITE PREVENTION (100% COMPLIANCE)**

### Rule 1: NEVER Rewrite Entire Files
- **EXISTING FILES ARE OFF-LIMITS** for complete rewrites
- **ONLY modify specific lines** that need changes
- **PRESERVE ALL existing code** unless explicitly told to remove
- **USE Cursor AI editor** for targeted modifications
- **SHOW ONLY what needs to change** - never the entire file

### Rule 2: Mandatory Minimal Change Format
```
// ONLY show the specific change needed:

// Add this function after line 45:
function newFunction() {
    // Implementation here
}

// OR

// Replace line 23:
- oldCode();
+ newCode();

// OR

// Insert after line 67:
// ... existing code ...
newCode();
// ... existing code ...
```

### Rule 3: File Rewrite Prevention Workflow
1. **Check if file exists** - if yes, use incremental changes only
2. **Identify specific lines** that need modification
3. **Show only changes** - never rewrite entire file
4. **Preserve context** - show 2-3 lines before and after changes
5. **Use line numbers** - reference exact locations for changes

### Rule 4: Anti-Rewrite Enforcement
- **If file > 100 lines**: Use incremental changes only
- **If file > 500 lines**: Break into multiple small changes
- **If file > 1000 lines**: Use Cursor AI editor with incremental changes only
- **Maximum change scope**: 50 lines per change
- **Multiple changes**: Break into separate operations

### Rule 5: File Rewrite Violation Penalties
- **File Rewrite Violation**: If Cursor AI rewrites entire files
  - **Penalty**: Must immediately stop and use incremental changes
  - **Verification**: Must prove only specific lines were changed
  - **Documentation**: Must document the violation and correction

### Rule 6: Change Size Violation Penalties
- **Large Change Violation**: If Cursor AI makes changes > 50 lines
  - **Penalty**: Must break into smaller, focused changes
  - **Verification**: Must prove changes are under 50 lines each
  - **Documentation**: Must document the violation and correction

## 12. Rule Violation Penalties (NEW - ENFORCEMENT)

### Penalties for Not Following Rules
- **Terminal Command Violation**: If Cursor AI uses terminal for code changes
  - **Penalty**: Must immediately switch to Cursor AI editor
  - **Verification**: Must prove Cursor AI editor was used for changes
  - **Documentation**: Must document the violation

- **User Approval Violation**: If Cursor AI acts without user approval
  - **Penalty**: Must stop immediately and ask for approval
  - **Verification**: Must get explicit user confirmation
  - **Documentation**: Must document the violation

- **Complete File Reading Violation**: If Cursor AI only reads partial files
  - **Penalty**: Must read entire file using terminal commands
  - **Verification**: Must prove complete file reading
  - **Documentation**: Must document the violation

## Conclusion

These core behavior and user approval rules ensure that Cursor AI always acts with proper user approval, uses terminal commands for scanning and understanding, and uses Cursor AI editor for all code changes. The clear separation prevents confusion and ensures proper workflow.

**Remember: Terminal for scanning, Cursor AI editor for code changes, user approval always required!**


These core behavior and user approval rules ensure that Cursor AI always acts with proper user approval, uses terminal commands for scanning and understanding, and uses Cursor AI editor for all code changes. The clear separation prevents confusion and ensures proper workflow.

**Remember: Terminal for scanning, Cursor AI editor for code changes, user approval always required!**
