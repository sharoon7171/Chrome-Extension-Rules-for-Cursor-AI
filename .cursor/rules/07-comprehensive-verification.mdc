---
description: Comprehensive verification rules to ensure complete implementation of changes, additions, and deletions with nothing missed
globs: ['**/*']
alwaysApply: true
---

# Comprehensive Verification and Quality Assurance Rules

## Core Principle
- **Verify completely** that all changes, additions, or deletions are fully implemented
- **Ensure nothing is missed** during any code modification
- **Implement comprehensive testing** and validation for all changes
- **Maintain code quality** through systematic verification processes
- **ALWAYS require user approval** before making any changes or implementations

## Sequential Code Application (NEW SECTION)

### Step-by-Step Implementation Process
1. **Break down complex changes** into individual, testable steps
2. **Apply one change at a time** - never multiple changes simultaneously
3. **Verify each step** before proceeding to the next
4. **Use incremental commits** for complex modifications
5. **Test functionality** after each significant change

### Code Application Best Practices
- **Single responsibility per change** - each modification should have one clear purpose
- **Atomic commits** - each change should be complete and functional
- **Rollback capability** - maintain ability to undo changes if needed
- **Validation checkpoints** - verify code works after each major step

### Preventing Application Errors
- **Clear change descriptions** - document exactly what each change does
- **Before/after comparisons** - show what the code looked like vs. what it should look like
- **Context preservation** - maintain surrounding code structure and formatting
- **Import verification** - ensure all necessary imports are added/updated

## User Approval Requirement
- **NEVER proceed with any changes** without explicit user confirmation
- **Ask for permission** before implementing, modifying, or deleting any code
- **Wait for user response** before executing any planned actions
- **Confirm approved actions** before proceeding with implementation

## Comprehensive Code Analysis Requirement
- **NEVER skip any part of code files** - read everything completely
- **Scan files systematically** in logical segments to ensure thorough understanding
- **Verify complete comprehension** before making any recommendations or changes
- **Prevent project issues** caused by incomplete code analysis
- **Read entire files** from beginning to end before making changes

## Terminal Verification Requirement
- **ALWAYS use terminal commands** for verification of any code changes or project status
- **Terminal verification is the perfect way** to ensure code works correctly
- **Verify dependencies** using package managers and version checks
- **Test code execution** by running it in the terminal
- **Check project status** using git, build tools, and runtime verification

### Terminal Verification Commands
- **Code execution**: Run scripts, tests, and applications
- **Dependency verification**: Check package versions, installations, and conflicts
- **Build verification**: Compile, build, and package projects
- **Git status**: Check repository state, commits, and branches
- **File system**: Verify file existence, permissions, and structure
- **Environment**: Check system requirements and configurations

### Verification Process
1. **Plan verification steps** using appropriate terminal commands
2. **Execute commands systematically** to verify each aspect
3. **Verify Chrome extension compliance** - check against latest August 2025 policies
4. **Interpret results** and identify any issues or errors
5. **Report findings** to the user before proceeding
6. **Ask for user approval** before making any changes based on verification

### Chrome Extension Compliance Verification
- **Check Manifest V3 compliance** - verify manifest.json follows standards
- **Verify code readability** - ensure no obfuscated code
- **Validate permissions** - confirm minimal necessary permissions requested
- **Test security requirements** - verify CSP, HTTPS usage, input validation
- **Confirm API usage** - ensure only official Chrome APIs are used

## Change Implementation Verification

### Before Making Changes
1. **Analyze the complete scope** of what needs to be changed
2. **Identify all affected components** and dependencies
3. **Plan the implementation** step by step
4. **Check for potential side effects** of the changes
5. **Ask for user approval** before proceeding with any changes

### During Implementation
1. **Implement changes systematically** following the planned approach
2. **Update all related files** that are affected by the change
3. **Maintain consistency** across the entire codebase
4. **Document changes** as they are made

### After Implementation
1. **Verify all planned changes** have been completed
2. **Test functionality** to ensure it works as expected
3. **Check for any broken references** or missing imports
4. **Validate that nothing was accidentally removed** or modified

## Addition Verification

### When Adding New Features
1. **Complete feature implementation** - all planned functionality
2. **Update all necessary files** - components, styles, tests, docs
3. **Add proper error handling** and validation
4. **Include comprehensive documentation** and comments
5. **Update related configuration** files if needed

### Verification Checklist for Additions
- [ ] All planned functionality implemented
- [ ] Error handling and validation added
- [ ] Documentation and comments included
- [ ] Related files updated
- [ ] Configuration updated if needed
- [ ] Tests written and passing
- [ ] No console errors or warnings
- [ ] Performance impact assessed

## Modification Verification

### When Modifying Existing Code
1. **Identify all locations** where the change needs to be applied
2. **Update all instances** consistently across the codebase
3. **Maintain backward compatibility** if required
4. **Update related documentation** and comments
5. **Verify dependent code** still works correctly

### Verification Checklist for Modifications
- [ ] All instances updated consistently
- [ ] Backward compatibility maintained
- [ ] Related documentation updated
- [ ] Dependent code tested
- [ ] No breaking changes introduced
- [ ] Performance impact assessed
- [ ] All tests passing

## Deletion Verification

### When Removing Code
1. **Identify all references** to the code being removed
2. **Remove all instances** completely and consistently
3. **Update import statements** and dependencies
4. **Remove unused imports** and dependencies
5. **Clean up related configuration** and documentation

### Verification Checklist for Deletions
- [ ] All code instances completely removed
- [ ] All references updated or removed
- [ ] Import statements cleaned up
- [ ] Unused dependencies removed
- [ ] Configuration updated
- [ ] Documentation updated
- [ ] No broken references remain
- [ ] All tests still passing

## Quality Assurance Processes

### Code Review Standards
- **Peer review** for all significant changes
- **Automated testing** for functionality validation
- **Static code analysis** for quality checks
- **Performance testing** for impact assessment

### Testing Requirements
- **Unit tests** for individual functions and components
- **Integration tests** for component interactions
- **End-to-end tests** for complete user workflows
- **Regression testing** to ensure no existing functionality is broken

### Documentation Standards
- **Inline comments** explaining complex logic
- **API documentation** for public interfaces
- **Architecture documentation** for system design
- **Change logs** for tracking modifications

## Implementation Examples

### Good Practice - Complete Feature Addition
```javascript
// ✅ GOOD: Complete implementation with all necessary parts
// 1. Main functionality
export function newFeature() {
    // Implementation with error handling
    try {
        // Core logic
    } catch (error) {
        console.error('Feature failed:', error);
        throw error;
    }
}

// 2. Tests
describe('newFeature', () => {
    it('should work correctly', () => {
        // Test implementation
    });
});

// 3. Documentation
/**
 * New feature that does X, Y, and Z
 * @param {string} input - Input parameter
 * @returns {Promise<Result>} Result of the operation
 */
```

### Good Practice - Complete Code Removal
```javascript
// ✅ GOOD: Complete removal with cleanup
// 1. Remove main function
// export function oldFeature() { ... } // REMOVED

// 2. Remove from exports
export {
    // oldFeature, // REMOVED
    remainingFeature
};

// 3. Update imports in other files
// import { oldFeature } from './utils'; // REMOVED
```

## Benefits
- **Complete implementation** - Nothing is missed or incomplete
- **Higher code quality** - Systematic verification processes
- **Reduced bugs** - Comprehensive testing and validation
- **Better maintainability** - Clean, consistent codebase
- **Faster debugging** - Clear documentation and error handling
- **Team confidence** - Systematic approach to changes

- **Reduced bugs** - Comprehensive testing and validation
- **Better maintainability** - Clean, consistent codebase
- **Faster debugging** - Clear documentation and error handling
- **Team confidence** - Systematic approach to changes

- **Reduced bugs** - Comprehensive testing and validation
- **Better maintainability** - Clean, consistent codebase
- **Faster debugging** - Clear documentation and error handling
- **Team confidence** - Systematic approach to changes

- **Reduced bugs** - Comprehensive testing and validation
- **Better maintainability** - Clean, consistent codebase
- **Faster debugging** - Clear documentation and error handling
- **Team confidence** - Systematic approach to changes
